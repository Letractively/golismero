- Usar un user-agent aleatorio para cada petición o el mismo.
- Poner como parámetro de red que se pueda explorar un sitio con un regex, subdominos.
- No funciona bien el método de obtener información cuando se requiere terra.es sin user-agent. Devuelve
un script para redireccionar, pero desde linea de comandos no.
- Poner el contador de palabras en cada response.


- Implementar el método toString en cada tipo de Result.
- En el results manager activas una comprobación por la que un mismo resultado no es enviado 2 veces, para no entrar en barrena y que los plugins no acaben nunca. MD5 con la info?
- Añadir un método de parar (interrumpir). Bien sean hilos o procesos.
- Distinguir los tipos de resultados al guardarlos y estructuralos, aunque no hace falta porque cada tipo
de resultado ya contiene el tipo y subtipo que es.
- Creo que los plugins se añaden a mas de una lista cuando se añaden al notifier, eso implica que se envíe 2 veces un mismo mensaje.
- Implementar un método "break" en el notifier.
- Los plugins no pueden escribir en la consola, para eso está el UI plugin. Hay que hacer algo para que los plugins todo lo que escriban sea solo de log.
- Modificar el notifier para que sea reutilizable por uimanager y las audit.
- Modificar el orchester para comprobar que se llama al init
- Los plugins tipo UI no reciben los mensajes (problema)
- Los plugins de UI tiene una método de entrada/salida por consola diferente, con un método add_output, para poder añadir en std o un fichero de texto.


+ Modificar el singleton para que se llame al __init__ solo 1 vez


El messaje manager no debe de saber nada del runmode, es el orchester quien tiene que configurarlo.


- Cambiar el singleton a esto:

class _singleton(type):
    "Implementation of the Singleton pattern"

    def __init__(cls, name, bases, dict):
        super(Singleton, cls).__init__(name, bases, dict)
        cls.instance = None

    def __call__(cls,*args,**kw):
        if cls.instance is None:
            cls.instance = super(Singleton, cls).__call__(*args, **kw)
        return cls.instance

class Singleton(type):
    "Implementation of the Singleton pattern"
    __metaclass__ = _singleton